<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebXR AR Aircraft Compass</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      flex-direction: column;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
    }
    button {
      padding: 15px 30px;
      font-size: 18px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    #compass2d {
      width: 200px;
      height: 200px;
      border: 3px solid #aaa;
      border-radius: 50%;
      position: relative;
      background: radial-gradient(circle at center, #222 60%, #111 100%);
      margin: 20px;
    }
    .needle2d {
      width: 3px;
      height: 100px;
      background: red;
      position: absolute;
      top: 50%;
      left: 50%;
      transform-origin: bottom center;
      transform: translate(-50%, -100%) rotate(0deg);
    }
  </style>
</head>
<body>
  <div id="info">
    <div>Heading: <span id="heading">--</span>Â°</div>
    <div>AR Status: <span id="status">Not started</span></div>
  </div>

  <button id="startCompass">Start 2D Compass</button>
  <button id="startAR">Start AR Compass</button>
  
  <div id="compass2d">
    <div class="needle2d"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, compass, needle, arSession;
    let currentHeading = 0;
    
    const needle2d = document.querySelector('.needle2d');
    const startCompassBtn = document.getElementById('startCompass');
    const startARBtn = document.getElementById('startAR');
    const headingSpan = document.getElementById('heading');
    const statusSpan = document.getElementById('status');

    // Check WebXR support
    async function checkARSupport() {
      if ('xr' in navigator) {
        try {
          const supported = await navigator.xr.isSessionSupported('immersive-ar');
          if (!supported) {
            startARBtn.disabled = true;
            startARBtn.textContent = 'AR Not Supported';
            statusSpan.textContent = 'AR not supported on this device';
          }
        } catch (error) {
          startARBtn.disabled = true;
          startARBtn.textContent = 'AR Check Failed';
          statusSpan.textContent = 'Error checking AR support';
        }
      } else {
        startARBtn.disabled = true;
        startARBtn.textContent = 'WebXR Not Available';
        statusSpan.textContent = 'WebXR not available';
      }
    }

    // Initialize Three.js scene
    function initThreeJS() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Create aircraft-style compass
      const compassGroup = new THREE.Group();
      
      // Main compass ring (outer)
      const outerRingGeometry = new THREE.RingGeometry(0.18, 0.2, 64);
      const outerRingMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, 
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.9
      });
      const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
      compassGroup.add(outerRing);

      // Inner compass face
      const faceGeometry = new THREE.CircleGeometry(0.18, 64);
      const faceMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x1a1a1a, 
        transparent: true, 
        opacity: 0.7,
        side: THREE.DoubleSide 
      });
      const compassFace = new THREE.Mesh(faceGeometry, faceMaterial);
      compassFace.position.z = -0.001; // Slightly behind ring
      compassGroup.add(compassFace);

      // Create rotating compass card with direction markings
      const compassCard = new THREE.Group();
      
      // Direction markers and text
      const directions = [
        { angle: 0, text: 'N', color: 0xff4444, major: true },
        { angle: 30, text: 'NE', color: 0xffffff, major: false },
        { angle: 60, text: '6', color: 0xffffff, major: false },
        { angle: 90, text: 'E', color: 0xffffff, major: true },
        { angle: 120, text: '12', color: 0xffffff, major: false },
        { angle: 150, text: 'SE', color: 0xffffff, major: false },
        { angle: 180, text: 'S', color: 0xffffff, major: true },
        { angle: 210, text: 'SW', color: 0xffffff, major: false },
        { angle: 240, text: '24', color: 0xffffff, major: false },
        { angle: 270, text: 'W', color: 0xffffff, major: true },
        { angle: 300, text: '30', color: 0xffffff, major: false },
        { angle: 330, text: 'NW', color: 0xffffff, major: false }
      ];

      directions.forEach(dir => {
        const angleRad = (dir.angle * Math.PI) / 180;
        const radius = 0.15;
        
        // Create tick marks
        const tickLength = dir.major ? 0.02 : 0.01;
        const tickGeometry = new THREE.BoxGeometry(0.002, tickLength, 0.001);
        const tickMaterial = new THREE.MeshBasicMaterial({ color: dir.color });
        const tick = new THREE.Mesh(tickGeometry, tickMaterial);
        
        tick.position.x = Math.sin(angleRad) * (radius + tickLength/2);
        tick.position.y = Math.cos(angleRad) * (radius + tickLength/2);
        tick.rotation.z = -angleRad;
        compassCard.add(tick);
        
        // Create direction labels using small boxes to represent text
        if (dir.major || dir.text.length <= 2) {
          const labelSize = dir.major ? 0.008 : 0.006;
          const labelGeometry = new THREE.BoxGeometry(labelSize, labelSize, 0.001);
          const labelMaterial = new THREE.MeshBasicMaterial({ color: dir.color });
          const label = new THREE.Mesh(labelGeometry, labelMaterial);
          
          label.position.x = Math.sin(angleRad) * (radius - 0.03);
          label.position.y = Math.cos(angleRad) * (radius - 0.03);
          compassCard.add(label);
        }
      });

      // Add degree markings around the compass
      for (let i = 0; i < 360; i += 10) {
        if (i % 30 !== 0) { // Skip major direction angles
          const angleRad = (i * Math.PI) / 180;
          const tickGeometry = new THREE.BoxGeometry(0.001, 0.008, 0.001);
          const tickMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
          const tick = new THREE.Mesh(tickGeometry, tickMaterial);
          
          tick.position.x = Math.sin(angleRad) * 0.165;
          tick.position.y = Math.cos(angleRad) * 0.165;
          tick.rotation.z = -angleRad;
          compassCard.add(tick);
        }
      }

      compassGroup.add(compassCard);
      compass = compassCard; // This will rotate with heading
      
      // Fixed aircraft symbol (triangle pointing forward)
      const aircraftGeometry = new THREE.ConeGeometry(0.012, 0.025, 3);
      const aircraftMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
      const aircraftSymbol = new THREE.Mesh(aircraftGeometry, aircraftMaterial);
      aircraftSymbol.rotation.x = Math.PI / 2;
      aircraftSymbol.position.y = 0.08;
      compassGroup.add(aircraftSymbol);

      // Position compass to follow camera/phone orientation
      compassGroup.position.set(0, -0.25, -0.4);
      scene.add(compassGroup);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
      scene.add(ambientLight);
    }

    // Handle device orientation
    function handleOrientation(event) {
      const alpha = event.alpha || 0;
      currentHeading = alpha;
      headingSpan.textContent = Math.round(alpha);
      
      // Update 2D needle
      needle2d.style.transform = `translate(-50%, -100%) rotate(${alpha}deg)`;
      
      // Update 3D needle if in AR
      if (needle && arSession) {
        needle.rotation.z = -alpha * Math.PI / 180; // Convert to radians and invert
      }
    }

    // Start 2D compass
    startCompassBtn.addEventListener('click', async () => {
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const response = await DeviceOrientationEvent.requestPermission();
          if (response === 'granted') {
            window.addEventListener('deviceorientation', handleOrientation);
            startCompassBtn.textContent = '2D Compass Active';
            startCompassBtn.disabled = true;
            statusSpan.textContent = '2D compass running';
          } else {
            alert('Permission denied for device orientation.');
          }
        } catch (error) {
          alert('Error requesting orientation permission: ' + error);
        }
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
        startCompassBtn.textContent = '2D Compass Active';
        startCompassBtn.disabled = true;
        statusSpan.textContent = '2D compass running';
      }
    });

    // Start AR session
    startARBtn.addEventListener('click', async () => {
      try {
        statusSpan.textContent = 'Starting AR...';
        
        if (!scene) {
          initThreeJS();
        }

        arSession = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: [],
          optionalFeatures: ['local', 'local-floor', 'viewer', 'dom-overlay'],
        });

        await renderer.xr.setSession(arSession);
        
        // Try different reference spaces in order of preference
        let referenceSpace;
        const spaceTypes = ['local', 'local-floor', 'viewer'];
        
        for (const spaceType of spaceTypes) {
          try {
            referenceSpace = await arSession.requestReferenceSpace(spaceType);
            console.log(`Using reference space: ${spaceType}`);
            statusSpan.textContent = `AR active (${spaceType} space)`;
            break;
          } catch (e) {
            console.log(`${spaceType} reference space not supported`);
          }
        }
        
        if (!referenceSpace) {
          throw new Error('No supported reference space found');
        }
        
        arSession.addEventListener('end', () => {
          arSession = null;
          statusSpan.textContent = 'AR session ended';
          startARBtn.disabled = false;
          startARBtn.textContent = 'Start AR Compass';
        });

        startARBtn.disabled = true;
        startARBtn.textContent = 'AR Active';
        statusSpan.textContent = 'AR compass running';

        // Start render loop
        renderer.setAnimationLoop(render);

        // Ensure orientation tracking is active
        if (!window.DeviceOrientationEvent || !window.addEventListener) {
          console.log('Orientation events not available');
        }

      } catch (error) {
        console.error('AR Error:', error);
        statusSpan.textContent = 'AR failed: ' + error.message;
        alert('Failed to start AR: ' + error.message);
      }
    });

    function render() {
      if (compass && arSession) {
        // Make compass always face the camera (billboard effect)
        const compassGroup = compass.parent;
        compassGroup.lookAt(camera.position);
        compassGroup.rotateY(Math.PI); // Flip to face correct direction
        
        // Rotate the compass card based on device heading
        // Aircraft compass rotates opposite to heading
        compass.rotation.z = currentHeading * Math.PI / 180;
      }
      
      renderer.render(scene, camera);
    }

    // Initialize
    checkARSupport();

    // Handle window resize
    window.addEventListener('resize', () => {
      if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  </script>
</body>
</html>





